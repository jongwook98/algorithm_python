# 해당 문제의 점화식은 곰곰히 생각해보면 떠올릴 수 있을 것 같다.
# 3가지 수로 4를 만드는 것을 생각해본다면

# 2가지 수로 4를 만드는 경우, 2가지 수로 3을 만드는 경우 2가지 수로 2를 만드는 경우, 2가지 수로 1을 만드는 경우 2가지 수로 0을 만드는 경우
# 각각의 경우에서 부족한 수만큼 더한다면 새로운 경우가 생긴다

# 또 2가지 수로 4를 만드는 경우는
# 1가지 수로 4, (1, 3), (1, 2), (1, 1), (1, 0) 의 경우를 더한 것이므로

# DP[k][n] = DP[k-1][n] + DP[k-1][n-1] + DP[k-1][n-2] ... + DP[k-1][0] 이고
# DP[k][n-1]            = DP[k-1][n-1] + DP[k-1][n-2] ... + DP[k-1][0] 이므로

# DP[k][n] = DP[k-1][n] + DP[k][n-1] 이 된다.

N, K = map(int, input().split())
DP = [[1 for _ in range(N+1)] for _ in range(K)]

for n in range(1, N+1):
    for k in range(1, K):
        DP[k][n] = ((DP[k-1][n] + DP[k][n-1]) % 1000000000)

print(DP[K-1][N] % 1000000000)